import { Node, Edge } from 'reactflow';
import { CustomNodeData } from '../components/nodes/CustomNodes';

export type Language = 'python' | 'javascript' | 'cpp' | 'pseudocode';

interface CodeGeneratorOptions {
  language: Language;
  indentSize?: number;
}

export class CodeGenerator {
  private language: Language;
  private indentSize: number;
  private indent: string;

  constructor(options: CodeGeneratorOptions) {
    this.language = options.language;
    this.indentSize = options.indentSize || 4;
    this.indent = ' '.repeat(this.indentSize);
  }

  generateCode(nodes: Node<CustomNodeData>[], edges: Edge[]): string {
    switch (this.language) {
      case 'python':
        return this.generatePythonCode(nodes, edges);
      case 'javascript':
        return this.generateJavaScriptCode(nodes, edges);
      case 'cpp':
        return this.generateCppCode(nodes, edges);
      case 'pseudocode':
        return this.generatePseudoCode(nodes, edges);
      default:
        return '';
    }
  }

  private generatePythonCode(nodes: Node<CustomNodeData>[], edges: Edge[]): string {
    let code = '# Generated by VVS\n\n';

    // Generate function definitions
    nodes.forEach(node => {
      if (!node.data) return;
      
      switch (node.type) {
        case 'ifStatement':
          code += this.generatePythonIfStatement(node);
          break;
        case 'print':
          code += this.generatePythonPrint(node);
          break;
        
        // Array Operations
        case 'arrayLength':
          code += `${node.id}_length = len(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayGet':
          code += `${node.id}_element = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}]\n`;
          break;
        case 'arraySet':
          code += `${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}] = ${node.data.inputs?.[2].id}\n`;
          break;
        case 'arrayPush':
          code += `${node.data.inputs?.[0].id}.append(${node.data.inputs?.[1].id})\n`;
          code += `${node.id}_length = len(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayPop':
          code += `${node.id}_element = ${node.data.inputs?.[0].id}.pop()\n`;
          break;
        case 'arrayInsert':
          code += `${node.data.inputs?.[0].id}.insert(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id})\n`;
          code += `${node.id}_length = len(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayRemove':
          code += `${node.id}_element = ${node.data.inputs?.[0].id}.pop(${node.data.inputs?.[1].id})\n`;
          break;
        case 'arraySlice':
          code += `${node.id}_result = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}:${node.data.inputs?.[2].id}]\n`;
          break;
        case 'arrayConcat':
          code += `${node.id}_result = ${node.data.inputs?.[0].id} + ${node.data.inputs?.[1].id}\n`;
          break;
        case 'arrayFind':
          code += `try:\n`;
          code += `${this.indent}${node.id}_result = next(x for x in ${node.data.inputs?.[0].id} if ${node.data.inputs?.[1].id}(x))\n`;
          code += `${this.indent}${node.id}_found = True\n`;
          code += `except StopIteration:\n`;
          code += `${this.indent}${node.id}_result = None\n`;
          code += `${this.indent}${node.id}_found = False\n`;
          break;
        case 'arrayFilter':
          code += `${node.id}_result = list(filter(${node.data.inputs?.[1].id}, ${node.data.inputs?.[0].id}))\n`;
          break;
        case 'arrayMap':
          code += `${node.id}_result = list(map(${node.data.inputs?.[1].id}, ${node.data.inputs?.[0].id}))\n`;
          break;
        case 'arrayReduce':
          code += `from functools import reduce\n`;
          code += `${node.id}_result = reduce(${node.data.inputs?.[1].id}, ${node.data.inputs?.[0].id}, ${node.data.inputs?.[2].id})\n`;
          break;
        case 'arraySort':
          code += `${node.id}_result = sorted(${node.data.inputs?.[0].id}, key=${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayReverse':
          code += `${node.id}_result = ${node.data.inputs?.[0].id}[::-1]\n`;
          break;
        case 'arrayJoin':
          code += `${node.id}_result = ${node.data.inputs?.[1].id}.join(map(str, ${node.data.inputs?.[0].id}))\n`;
          break;
        case 'arrayIncludes':
          code += `${node.id}_result = ${node.data.inputs?.[1].id} in ${node.data.inputs?.[0].id}\n`;
          break;
        case 'arrayIndexOf':
          code += `try:\n`;
          code += `${this.indent}${node.id}_index = ${node.data.inputs?.[0].id}.index(${node.data.inputs?.[1].id})\n`;
          code += `except ValueError:\n`;
          code += `${this.indent}${node.id}_index = -1\n`;
          break;
        case 'arrayLastIndexOf':
          code += `${node.id}_index = len(${node.data.inputs?.[0].id}) - 1 - ${node.data.inputs?.[0].id}[::-1].index(${node.data.inputs?.[1].id}) if ${node.data.inputs?.[1].id} in ${node.data.inputs?.[0].id} else -1\n`;
          break;
        case 'arrayClear':
          code += `${node.data.inputs?.[0].id}.clear()\n`;
          break;
        case 'arrayIsEmpty':
          code += `${node.id}_result = len(${node.data.inputs?.[0].id}) == 0\n`;
          break;
      }
    });

    // Generate main execution block
    code += '\n# Main execution\n';
    code += 'if __name__ == "__main__":\n';
    code += `${this.indent}# Add your execution code here\n`;
    code += `${this.indent}pass\n`;

    return code;
  }

  private generateJavaScriptCode(nodes: Node<CustomNodeData>[], edges: Edge[]): string {
    let code = '// Generated by VVS\n\n';
    
    // Generate function definitions
    nodes.forEach(node => {
      if (!node.data) return;
      
      switch (node.type) {
        case 'ifStatement':
          code += this.generateJavaScriptIfStatement(node);
          break;
        case 'print':
          code += this.generateJavaScriptPrint(node);
          break;
        
        // String Operations
        case 'stringLength':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.length;\n`;
          break;
        case 'concat':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id} + ${node.data.inputs?.[1].id};\n`;
          break;
        case 'substring':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.substring(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'trim':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.trim();\n`;
          break;
        case 'toUpperCase':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.toUpperCase();\n`;
          break;
        case 'toLowerCase':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.toLowerCase();\n`;
          break;
        case 'replace':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.replace(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'split':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.split(${node.data.inputs?.[1].id});\n`;
          break;
        case 'indexOf':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.indexOf(${node.data.inputs?.[1].id});\n`;
          break;
        case 'lastIndexOf':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.lastIndexOf(${node.data.inputs?.[1].id});\n`;
          break;
        case 'startsWith':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.startsWith(${node.data.inputs?.[1].id});\n`;
          break;
        case 'endsWith':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.endsWith(${node.data.inputs?.[1].id});\n`;
          break;
        case 'includes':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.includes(${node.data.inputs?.[1].id});\n`;
          break;
        case 'repeat':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.repeat(${node.data.inputs?.[1].id});\n`;
          break;
        case 'charAt':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.charAt(${node.data.inputs?.[1].id});\n`;
          break;
        case 'padStart':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.padStart(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'padEnd':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.padEnd(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'match':
          code += `const ${node.id}_matches = ${node.data.inputs?.[0].id}.match(${node.data.inputs?.[1].id});\n`;
          code += `const ${node.id}_success = ${node.id}_matches !== null;\n`;
          break;
        case 'search':
          code += `const ${node.id}_index = ${node.data.inputs?.[0].id}.search(${node.data.inputs?.[1].id});\n`;
          code += `const ${node.id}_found = ${node.id}_index !== -1;\n`;
          break;
        case 'format':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.replace(/\{(\d+)\}/g, (_, i) => ${node.data.inputs?.[1].id}[i]);\n`;
          break;
        
        // Array Operations
        case 'arrayLength':
          code += `const ${node.id}_length = ${node.data.inputs?.[0].id}.length;\n`;
          break;
        case 'arrayGet':
          code += `const ${node.id}_element = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}];\n`;
          break;
        case 'arraySet':
          code += `${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}] = ${node.data.inputs?.[2].id};\n`;
          break;
        case 'arrayPush':
          code += `const ${node.id}_length = ${node.data.inputs?.[0].id}.push(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayPop':
          code += `const ${node.id}_element = ${node.data.inputs?.[0].id}.pop();\n`;
          break;
        case 'arrayInsert':
          code += `${node.data.inputs?.[0].id}.splice(${node.data.inputs?.[1].id}, 0, ${node.data.inputs?.[2].id});\n`;
          code += `const ${node.id}_length = ${node.data.inputs?.[0].id}.length;\n`;
          break;
        case 'arrayRemove':
          code += `const ${node.id}_element = ${node.data.inputs?.[0].id}.splice(${node.data.inputs?.[1].id}, 1)[0];\n`;
          break;
        case 'arraySlice':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.slice(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'arrayConcat':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.concat(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayFind':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.find(${node.data.inputs?.[1].id});\n`;
          code += `const ${node.id}_found = ${node.id}_result !== undefined;\n`;
          break;
        case 'arrayFilter':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.filter(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayMap':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.map(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayReduce':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.reduce(${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          break;
        case 'arraySort':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.sort(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayReverse':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.reverse();\n`;
          break;
        case 'arrayJoin':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.join(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayIncludes':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.includes(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayIndexOf':
          code += `const ${node.id}_index = ${node.data.inputs?.[0].id}.indexOf(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayLastIndexOf':
          code += `const ${node.id}_index = ${node.data.inputs?.[0].id}.lastIndexOf(${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayClear':
          code += `${node.data.inputs?.[0].id}.length = 0;\n`;
          break;
        case 'arrayIsEmpty':
          code += `const ${node.id}_result = ${node.data.inputs?.[0].id}.length === 0;\n`;
          break;
      }
    });

    return code;
  }

  private generateCppCode(nodes: Node<CustomNodeData>[], edges: Edge[]): string {
    let code = '// Generated by VVS\n\n';
    code += '#include <iostream>\n';
    code += '#include <vector>\n';
    code += '#include <string>\n';
    code += '#include <algorithm>\n';
    code += '#include <numeric>\n';
    code += '#include <iterator>\n\n';
    code += 'using namespace std;\n\n';
    
    // Generate function definitions
    nodes.forEach(node => {
      if (!node.data) return;
      
      switch (node.type) {
        case 'ifStatement':
          code += this.generateCppIfStatement(node);
          break;
        case 'print':
          code += this.generateCppPrint(node);
          break;
        
        // Array Operations
        case 'arrayLength':
          code += `size_t ${node.id}_length = ${node.data.inputs?.[0].id}.size();\n`;
          break;
        case 'arrayGet':
          code += `auto ${node.id}_element = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}];\n`;
          break;
        case 'arraySet':
          code += `${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}] = ${node.data.inputs?.[2].id};\n`;
          break;
        case 'arrayPush':
          code += `${node.data.inputs?.[0].id}.push_back(${node.data.inputs?.[1].id});\n`;
          code += `size_t ${node.id}_length = ${node.data.inputs?.[0].id}.size();\n`;
          break;
        case 'arrayPop':
          code += `auto ${node.id}_element = ${node.data.inputs?.[0].id}.back();\n`;
          code += `${node.data.inputs?.[0].id}.pop_back();\n`;
          break;
        case 'arrayInsert':
          code += `${node.data.inputs?.[0].id}.insert(${node.data.inputs?.[0].id}.begin() + ${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id});\n`;
          code += `size_t ${node.id}_length = ${node.data.inputs?.[0].id}.size();\n`;
          break;
        case 'arrayRemove':
          code += `auto ${node.id}_element = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}];\n`;
          code += `${node.data.inputs?.[0].id}.erase(${node.data.inputs?.[0].id}.begin() + ${node.data.inputs?.[1].id});\n`;
          break;
        case 'arraySlice':
          code += `vector<auto> ${node.id}_result(${node.data.inputs?.[0].id}.begin() + ${node.data.inputs?.[1].id}, ${node.data.inputs?.[0].id}.begin() + ${node.data.inputs?.[2].id});\n`;
          break;
        case 'arrayConcat':
          code += `vector<auto> ${node.id}_result = ${node.data.inputs?.[0].id};\n`;
          code += `${node.id}_result.insert(${node.id}_result.end(), ${node.data.inputs?.[1].id}.begin(), ${node.data.inputs?.[1].id}.end());\n`;
          break;
        case 'arrayFind':
          code += `auto ${node.id}_it = find_if(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), ${node.data.inputs?.[1].id});\n`;
          code += `auto ${node.id}_found = ${node.id}_it != ${node.data.inputs?.[0].id}.end();\n`;
          code += `auto ${node.id}_result = ${node.id}_found ? *${node.id}_it : decltype(${node.data.inputs?.[0].id}[0]){};\n`;
          break;
        case 'arrayFilter':
          code += `vector<auto> ${node.id}_result;\n`;
          code += `copy_if(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), back_inserter(${node.id}_result), ${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayMap':
          code += `vector<auto> ${node.id}_result;\n`;
          code += `transform(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), back_inserter(${node.id}_result), ${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayReduce':
          code += `auto ${node.id}_result = accumulate(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), ${node.data.inputs?.[2].id}, ${node.data.inputs?.[1].id});\n`;
          break;
        case 'arraySort':
          code += `vector<auto> ${node.id}_result = ${node.data.inputs?.[0].id};\n`;
          code += `sort(${node.id}_result.begin(), ${node.id}_result.end(), ${node.data.inputs?.[1].id});\n`;
          break;
        case 'arrayReverse':
          code += `vector<auto> ${node.id}_result = ${node.data.inputs?.[0].id};\n`;
          code += `reverse(${node.id}_result.begin(), ${node.id}_result.end());\n`;
          break;
        case 'arrayJoin':
          code += `string ${node.id}_result;\n`;
          code += `for (size_t i = 0; i < ${node.data.inputs?.[0].id}.size(); ++i) {\n`;
          code += `${this.indent}if (i > 0) ${node.id}_result += ${node.data.inputs?.[1].id};\n`;
          code += `${this.indent}${node.id}_result += to_string(${node.data.inputs?.[0].id}[i]);\n`;
          code += `}\n`;
          break;
        case 'arrayIncludes':
          code += `bool ${node.id}_result = find(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), ${node.data.inputs?.[1].id}) != ${node.data.inputs?.[0].id}.end();\n`;
          break;
        case 'arrayIndexOf':
          code += `auto ${node.id}_it = find(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), ${node.data.inputs?.[1].id});\n`;
          code += `ptrdiff_t ${node.id}_index = ${node.id}_it != ${node.data.inputs?.[0].id}.end() ? distance(${node.data.inputs?.[0].id}.begin(), ${node.id}_it) : -1;\n`;
          break;
        case 'arrayLastIndexOf':
          code += `auto ${node.id}_it = find_end(${node.data.inputs?.[0].id}.begin(), ${node.data.inputs?.[0].id}.end(), &${node.data.inputs?.[1].id}, &${node.data.inputs?.[1].id} + 1);\n`;
          code += `ptrdiff_t ${node.id}_index = ${node.id}_it != ${node.data.inputs?.[0].id}.end() ? distance(${node.data.inputs?.[0].id}.begin(), ${node.id}_it) : -1;\n`;
          break;
        case 'arrayClear':
          code += `${node.data.inputs?.[0].id}.clear();\n`;
          break;
        case 'arrayIsEmpty':
          code += `bool ${node.id}_result = ${node.data.inputs?.[0].id}.empty();\n`;
          break;
      }
    });

    // Generate main function
    code += '\nint main() {\n';
    code += `${this.indent}// Add your execution code here\n`;
    code += `${this.indent}return 0;\n`;
    code += '}\n';

    return code;
  }

  private generatePseudoCode(nodes: Node<CustomNodeData>[], edges: Edge[]): string {
    let code = 'ALGORITHM VVS_Flow\n\n';

    // Generate function definitions
    nodes.forEach(node => {
      if (!node.data) return;
      
      switch (node.type) {
        case 'ifStatement':
          code += this.generatePseudoIfStatement(node);
          break;
        case 'print':
          code += this.generatePseudoPrint(node);
          break;
        
        // Array Operations
        case 'arrayLength':
          code += `${node.id}_length = LENGTH(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayGet':
          code += `${node.id}_element = ${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}]\n`;
          break;
        case 'arraySet':
          code += `${node.data.inputs?.[0].id}[${node.data.inputs?.[1].id}] = ${node.data.inputs?.[2].id}\n`;
          break;
        case 'arrayPush':
          code += `APPEND ${node.data.inputs?.[1].id} TO ${node.data.inputs?.[0].id}\n`;
          code += `${node.id}_length = LENGTH(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayPop':
          code += `${node.id}_element = REMOVE_LAST(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayInsert':
          code += `INSERT ${node.data.inputs?.[2].id} AT ${node.data.inputs?.[1].id} IN ${node.data.inputs?.[0].id}\n`;
          code += `${node.id}_length = LENGTH(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayRemove':
          code += `${node.id}_element = REMOVE_AT(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arraySlice':
          code += `${node.id}_result = SLICE(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id})\n`;
          break;
        case 'arrayConcat':
          code += `${node.id}_result = CONCATENATE(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayFind':
          code += `${node.id}_result = FIND_FIRST(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          code += `${node.id}_found = ${node.id}_result IS NOT NULL\n`;
          break;
        case 'arrayFilter':
          code += `${node.id}_result = FILTER(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayMap':
          code += `${node.id}_result = MAP(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayReduce':
          code += `${node.id}_result = REDUCE(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id}, ${node.data.inputs?.[2].id})\n`;
          break;
        case 'arraySort':
          code += `${node.id}_result = SORT(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayReverse':
          code += `${node.id}_result = REVERSE(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayJoin':
          code += `${node.id}_result = JOIN(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayIncludes':
          code += `${node.id}_result = CONTAINS(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayIndexOf':
          code += `${node.id}_index = FIND_INDEX(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayLastIndexOf':
          code += `${node.id}_index = FIND_LAST_INDEX(${node.data.inputs?.[0].id}, ${node.data.inputs?.[1].id})\n`;
          break;
        case 'arrayClear':
          code += `CLEAR(${node.data.inputs?.[0].id})\n`;
          break;
        case 'arrayIsEmpty':
          code += `${node.id}_result = IS_EMPTY(${node.data.inputs?.[0].id})\n`;
          break;
      }
    });

    // Generate main execution block
    code += '\nBEGIN MAIN\n';
    code += `${this.indent}// Your execution code here\n`;
    code += 'END MAIN\n';

    return code;
  }

  private generatePythonIfStatement(node: Node<CustomNodeData>): string {
    const { inputs = [], outputs = [] } = node.data;
    const condition = inputs.find(input => input.id === 'condition');
    return `def ${node.id}_if():\n${this.indent}condition = True  # ${condition?.label || 'Replace with actual condition'}\n${this.indent}if condition:\n${this.indent}${this.indent}pass\n\n`;
  }

  private generatePythonPrint(node: Node<CustomNodeData>): string {
    const { inputs = [] } = node.data;
    const value = inputs.find(input => input.id === 'value');
    return `def ${node.id}_print():\n${this.indent}print("Hello VVS")  # ${value?.label || 'Replace with actual value'}\n\n`;
  }

  private generateJavaScriptIfStatement(node: Node<CustomNodeData>): string {
    const { inputs = [], outputs = [] } = node.data;
    const condition = inputs.find(input => input.id === 'condition');
    return `function ${node.id}_if() {\n${this.indent}const condition = true;  // ${condition?.label || 'Replace with actual condition'}\n${this.indent}if (condition) {\n${this.indent}${this.indent}// Add your code here\n${this.indent}}\n}\n\n`;
  }

  private generateJavaScriptPrint(node: Node<CustomNodeData>): string {
    const { inputs = [] } = node.data;
    const value = inputs.find(input => input.id === 'value');
    return `function ${node.id}_print() {\n${this.indent}console.log("Hello VVS");  // ${value?.label || 'Replace with actual value'}\n}\n\n`;
  }

  private generateCppIfStatement(node: Node<CustomNodeData>): string {
    const { inputs = [], outputs = [] } = node.data;
    const condition = inputs.find(input => input.id === 'condition');
    return `void ${node.id}_if() {\n${this.indent}bool condition = true;  // ${condition?.label || 'Replace with actual condition'}\n${this.indent}if (condition) {\n${this.indent}${this.indent}// Add your code here\n${this.indent}}\n}\n\n`;
  }

  private generateCppPrint(node: Node<CustomNodeData>): string {
    const { inputs = [] } = node.data;
    const value = inputs.find(input => input.id === 'value');
    return `void ${node.id}_print() {\n${this.indent}cout << "Hello VVS" << endl;  // ${value?.label || 'Replace with actual value'}\n}\n\n`;
  }

  private generatePseudoIfStatement(node: Node<CustomNodeData>): string {
    const { inputs = [], outputs = [] } = node.data;
    const condition = inputs.find(input => input.id === 'condition');
    return `PROCEDURE ${node.id}_if\n${this.indent}IF ${condition?.label || 'condition'} THEN\n${this.indent}${this.indent}// Your code here\n${this.indent}END IF\nEND PROCEDURE\n\n`;
  }

  private generatePseudoPrint(node: Node<CustomNodeData>): string {
    const { inputs = [] } = node.data;
    const value = inputs.find(input => input.id === 'value');
    return `PROCEDURE ${node.id}_print\n${this.indent}DISPLAY "${value?.label || 'message'}"\nEND PROCEDURE\n\n`;
  }
} 